# On Wrapper elements in TLP-doc

* Status: accepted
* Deciders: Joris MASSON, Lou-Evan ROUBY
* Date: 2024-07-22

Technical Story: [request #37211 Replace TLP-doc documentation][0]

## Why do we need Wrapper custom elements in TLP stories?

Throughout the Storybook stories that make up TLP-doc, you can find various custom elements called "Wrapper". They are most often used for "function API" components, for example TLP date pickers, TLP popovers, TLP modals, etc. Those components all require developers to call a function (for example `createModal()`) that take HTML elements as parameters. For example, Date pickers require an HTML input that will trigger the display of the date picker "pop-over" element.

The problems arise from Storybook's dynamic rendering combined with this "function API": we do not have access to some kind of Storybook event or callback that would be executed _after_ rendering the HTML elements. Storybook was initially built for React or Vue or similar frameworks, they have built-in "lifecycle" callbacks to deal with such cases, such as `onMounted()` in Vue 3. In our case, we are closer to Vanilla JavaScript DOM API, so we cannot use that. Storybook decorators also cannot help us, as they are executed _before_ the story renders, so we do not find our HTML elements when running `querySelector()` in a Storybook decorator function.

A Custom Element has a native "lifecycle" callback however: by leveraging `connectedCallback()`, we can query the DOM with `querySelector()`, and since it runs when the templating is done, it correctly finds our HTML elements. Therefore, we leverage this by creating "wrapper" custom elements. The goal of the wrapper custom element is to be the "glue" between the dynamic rendering of Storybook and our old "function API". At creation, `connectedCallback()` will run. We can write our stories so that the HTML elements we need to find are children of the Wrapper element itself, so inside our Wrapper element's code we can use `this.querySelector()` to easily find the HTML elements. We can then safely call our "function API" with the required HTML elements.

Some of those components also have options, so we document those options as Storybook "args". However, when those args change (for example, when we change the "placement" arg for TLP popovers), we want to destroy and re-create the component correctly with the new options. Again, we can leverage Custom Elements: we can define attributes, add them to `observedAttributes` and watch when their value changes with `attributeChangedCallback()`. Or, we can use properties and use a setter to destroy and re-create the component.

We decided to use a Storybook decorator to wrap the story in our custom Wrapper element, so that the wrapper's HTML code _does not appear_ in the "Show code" help box automatically generated by Storybook. Since the wrapper is only here to help us with Storybook, we do not want it to appear in the official documentation.

[0]: https://tuleap.net/plugins/tracker/?aid=37211
